package com.shuangpeng.Problem.p0901_1000;

import java.util.Arrays;

/**
 * @Description:
 * @Date 2022/2/15 4:55 PM
 * @Version 1.0
 */
public class Problem0924MinimizeMalwareSpread {

    public int minMalwareSpread0(int[][] graph, int[] initial) {
        int n = graph.length;
        int[] parent = new int[n];
        int[] size = new int[n];
        for (int i = 0; i < n; ++i) {
            parent[i] = i;
        }
        Arrays.fill(size, 1);
        for (int i = 0; i < n; ++i) {
            for (int j = 0; j < n; ++j) {
                if (graph[i][j] == 1 && i != j) {
                    union(parent, size, i, j);
                }
            }
        }
        int max = -1, ans = -1;
        for (int i : initial) {
            boolean flag = true;
            for (int j : initial) {
                if (i != j && find(parent, i) == find(parent, j)) {
                    flag = false;
                    break;
                }
            }
            int count = flag ? size[find(parent, i)] : 0;
            if (count > max) {
                max = count;
                ans = i;
            } else if (count == max) {
                ans = Math.min(ans, i);
            }
        }
        return ans;
    }

    private void union(int[] parent, int[] size, int i, int j) {
        int p1 = find(parent, i), p2 = find(parent, j);
        if (p1 != p2) {
            parent[p1] = p2;
            size[p2] += size[p1];
        }
    }

    private int find(int[] parent, int i) {
        return i == parent[i] ? i : (parent[i] = find(parent, parent[i]));
    }

    public int minMalwareSpread(int[][] graph, int[] initial) {
        int n = graph.length;
        UnionFind unionFind = new UnionFind(n);
        for (int i = 0; i < n; ++i) {
            for (int j = i + 1; j < n; ++j) {
                if (graph[i][j] == 1) {
                    unionFind.union(i, j);
                }
            }
        }
        int[] counts = new int[n];
        for (int i : initial) {
            ++counts[unionFind.find(i)];
        }
        int maxCount = -1, ans = -1;
        for (int i : initial) {
            int p = unionFind.find(i);
            if (counts[p] == 1) {
                int size = unionFind.size(p);
                if (size > maxCount) {
                    maxCount = size;
                    ans = i;
                } else if (size == maxCount) {
                    ans = Math.min(ans, i);
                }
            }
        }
        if (ans == -1) {
            ans = Integer.MAX_VALUE;
            for (int i : initial) {
                ans = Math.min(ans, i);
            }
        }
        return ans;
    }

    class UnionFind {
        int[] p;
        int[] sz;

        UnionFind(int n) {
            p = new int[n];
            sz = new int[n];
            for (int i = 0; i < n; ++i) {
                p[i] = i;
            }
            Arrays.fill(sz, 1);
        }

        int find(int i) {
            return i == p[i] ? i : (p[i] = find(p[i]));
        }

        void union(int i, int j) {
            int p1 = find(i), p2 = find(j);
            if (p1 != p2) {
                p[p1] = p2;
                sz[p2] += sz[p1];
            }
        }

        int size(int i) {
            return sz[find(i)];
        }
    }
}
