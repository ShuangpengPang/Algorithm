package com.shuangpeng.Problem.p0901_1000;

import java.util.*;

/**
 * @Description: Problem0928MinimizeMalwareSpreadII
 * @Date 2022/4/21 5:33 PM
 * @Version 1.0
 */
public class Problem0928MinimizeMalwareSpreadII {

    public int minMalwareSpread0(int[][] graph, int[] initial) {
        int n = graph.length;
        int[] visited = new int[n];
        Arrays.fill(visited, -1);
        for (int i : initial) {
            visited[i] = i;
        }
        int[] array = new int[n];
        for (int i : initial) {
            List<Integer> list = new ArrayList<>();
            for (int j = 0; j < n; ++j) {
                if (graph[i][j] == 1 && visited[j] == -1) {
                    list.add(j);
                }
            }
            int count = 1;
            for (int j : list) {
                if (visited[j] != -1) {
                    continue;
                }
                visited[j] = i;
                boolean isValid = true;
                int c = 1;
                Queue<Integer> queue = new LinkedList<>();
                queue.offer(j);
                while (!queue.isEmpty()) {
                    int p = queue.poll();
                    for (int k = 0; k < n; ++k) {
                        if (graph[p][k] == 1) {
                            if (visited[k] == -1) {
                                visited[k] = i;
                                ++c;
                                queue.offer(k);
                            } else if (visited[k] != i) {
                                isValid = false;
                            }
                        }
                    }
                }
                if (isValid) {
                    count += c;
                }
            }
            array[i] = count;
        }
        int maxCount = 0, ans = -1;
        for (int i = n - 1; i >= 0; --i) {
            if (array[i] >= maxCount) {
                maxCount = array[i];
                ans = i;
            }
        }
        return ans;
    }

    public int minMalwareSpread(int[][] graph, int[] initial) {
        int N = graph.length;
        int[] clean = new int[N];
        Arrays.fill(clean, 1);
        for (int x: initial)
            clean[x] = 0;

        // For each node u in initial, dfs to find
        // 'seen': all nodes not in initial that it can reach.
        ArrayList<Integer>[] infectedBy = new ArrayList[N];
        for (int i = 0; i < N; ++i)
            infectedBy[i] = new ArrayList();

        for (int u: initial) {
            Set<Integer> seen = new HashSet();
            dfs(graph, clean, u, seen);
            for (int v: seen)
                infectedBy[v].add(u);
        }

        // For each node u in initial, for every v not in initial
        // that is uniquely infected by u, add 1 to the contribution for u.
        int[] contribution = new int[N];
        for (int v = 0; v < N; ++v)
            if (infectedBy[v].size() == 1)
                contribution[infectedBy[v].get(0)]++;

        // Take the best answer.
        Arrays.sort(initial);
        int ans = initial[0], ansSize = -1;
        for (int u: initial) {
            int score = contribution[u];
            if (score > ansSize || score == ansSize && u < ans) {
                ans = u;
                ansSize = score;
            }
        }
        return ans;
    }

    public void dfs(int[][] graph, int[] clean, int u, Set<Integer> seen) {
        for (int v = 0; v < graph.length; ++v)
            if (graph[u][v] == 1 && clean[v] == 1 && !seen.contains(v)) {
                seen.add(v);
                dfs(graph, clean, v, seen);
            }
    }
}
